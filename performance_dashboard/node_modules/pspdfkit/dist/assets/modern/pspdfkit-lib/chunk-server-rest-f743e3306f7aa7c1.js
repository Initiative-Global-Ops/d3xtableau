/*!
 * PSPDFKit for Web 2021.4.2 (https://pspdfkit.com/web)
 * 
 * Copyright (c) 2016-2019 PSPDFKit GmbH. All rights reserved.
 * 
 * THIS SOURCE CODE AND ANY ACCOMPANYING DOCUMENTATION ARE PROTECTED BY INTERNATIONAL COPYRIGHT LAW
 * AND MAY NOT BE RESOLD OR REDISTRIBUTED. USAGE IS BOUND TO THE PSPDFKIT LICENSE AGREEMENT.
 * UNAUTHORIZED REPRODUCTION OR DISTRIBUTION IS SUBJECT TO CIVIL AND CRIMINAL PENALTIES.
 * This notice may not be removed from this file.
 * 
 * PSPDFKit uses several open source third-party components: https://pspdfkit.com/acknowledgements/web/
 */
(window.webpackJsonpPSPDFKit=window.webpackJsonpPSPDFKit||[]).push([[61],{650:function(t,e,a){"use strict";a.r(e),a.d(e,"RESTProvider",(function(){return u}));var s=a(2),o=a.n(s),i=a(4),n=a(3),r=a(41),d=a(125);class l extends(i.e({alreadyLoadedPages:Object(i.b)(),serverURL:null,authPayload:null,isLoaded:!1,isFormsEnabled:!0,loadBookmarksPromise:null,ignoredFormFieldNames:null})){}var c=a(175),h=a(229),m=a(8);class u{constructor(t,e,{isFormsEnabled:a}){o()(this,"canCreateBackendOrphanWidgets",!0),o()(this,"setDocumentHandleConflictCallback",(()=>{})),this.state=new l({serverURL:t,authPayload:e,isFormsEnabled:a})}async load(){return this.state=this.state.set("isLoaded",!0),this.state.isFormsEnabled&&await this._initializeFormFieldValues(),this}destroy(){}setReadStateCallbacks(t){this._readStateCallbacks=t}setAnnotationCallbacks(t){this.annotationCallbacks=t}setBookmarkCallbacks(t){this.bookmarkCallbacks=t}setFormFieldValueCallbacks(t){this.formFieldValueCallbacks=t}async createAnnotation(t,e){this._verifyLoaded();const{id:a,...s}=Object(r.o)(t),o={id:a,content:s};await this._request("/annotations","POST",o).then((t=>{if(200!==t.status)throw new n.a("PSPDFKit Server returned an error, when saving an annotation.");t.json().then((t=>{if("attachment_missing"===t.error){const t=function(t,e){const a=new FormData;return a.append("annotation",JSON.stringify(t)),e.forEach(((t,e)=>{e&&t.data&&a.append(e,t.data)})),a}(o,e);return this._request("/annotations","POST",t).then((t=>t.json()))}return t}))}))}async updateAnnotation(t){this._verifyLoaded();const{id:e,...a}=Object(r.o)(t);await this._request(`/annotations/${e}`,"PUT",{id:e,content:a})}async deleteAnnotation(t){this._verifyLoaded(),await this._request(`/annotations/${t.id}`,"DELETE")}async createBookmark(t){this._verifyLoaded(),await this.loadBookmarks();const{id:e,...a}=Object(d.b)(t);if(200!==(await this._request("/bookmarks","POST",{id:e,content:a})).status)throw new n.a("PSPDFKit Server returned an error, when saving an bookmark.")}async updateBookmark(t){this._verifyLoaded(),await this.loadBookmarks();const{id:e,...a}=Object(d.b)(t);await this._request(`/bookmarks/${e}`,"PUT",{id:e,content:a})}async deleteBookmark(t){this._verifyLoaded(),await this.loadBookmarks(),await this._request(`/bookmarks/${t}`,"DELETE")}async setFormFieldValue(t){this._verifyLoaded();const e={id:Object(c.b)(t),content:Object(r.s)(t)};await this._request("/form-field-values","POST",{formFieldValues:[e]})}async createFormFieldValue(){}async deleteFormFieldValue(){}async loadAnnotationsForPageIndex(t){if(this._verifyLoaded(),this.state.alreadyLoadedPages.has(t))await this.state.alreadyLoadedPages.get(t);else try{const e=this._request(`/page-${t}-annotations`,"GET").then((t=>t.json())).catch((t=>{throw t}));this.state=this.state.setIn(["alreadyLoadedPages",t],e);const a=await e;this.state=this.state.setIn(["alreadyLoadedPages",t],Promise.resolve());const s=Object(i.a)().withMutations((t=>{a.annotations.map((e=>{try{t.push(Object(r.c)(e.id,e.content))}catch(t){Object(n.j)(`Skipped creating annotation #${e.id} from payload because an error occurred while deserializing.`,e.content),Object(n.j)(t)}}))}));s.size>0&&(Object(m.a)(this.annotationCallbacks),this.annotationCallbacks.createAnnotations(s,Object(i.b)(),h.a))}catch(t){this._handleError(t,"annotations")}}async loadBookmarks(){if(this._verifyLoaded(),this.state.loadBookmarksPromise)await this.state.loadBookmarksPromise;else try{const t=this._request("/bookmarks","GET").then((t=>t.json())).then((t=>t.data)).catch((t=>{throw t}));this.state=this.state.set("loadBookmarksPromise",t);const e=await t;this.state=this.state.set("loadBookmarksPromise",Promise.resolve()),Object(m.a)(Array.isArray(e.bookmarks),"Unexpected reply from bookmarks endpoint.");const a=Object(i.a)().withMutations((t=>{e.bookmarks.forEach((e=>{try{t.push(Object(d.a)(e.id,e.content))}catch(t){Object(n.j)(`Skipped creating bookmark #${e.id} from payload because an error occurred while deserializing.`,e),Object(n.j)(t)}}))}));a.size>0&&(Object(m.a)(this.bookmarkCallbacks),this.bookmarkCallbacks.createBookmarks(a,h.a))}catch(t){this._handleError(t,"bookmarks")}}async syncChanges(){}async _initializeFormFieldValues(){const t=await this._request("/form-field-values","GET"),e=await t.json();Object(m.a)(Array.isArray(e.formFieldValues),"Unexpected reply from form-values endpoint.");const a=Object(i.a)(e.formFieldValues.map((({content:t})=>{try{return Object(r.f)(t)}catch(e){return Object(n.j)(`Skipped form field value ${t.name} from payload because an error occurred while deserializing.`,t),Object(n.j)(e),null}})).filter(Boolean));Object(m.a)(this.formFieldValueCallbacks),this.state.ignoredFormFieldNames&&this.state.ignoredFormFieldNames.size?this.formFieldValueCallbacks.setFormFieldValues(a.filter((t=>{var e;return!(null!==(e=this.state.ignoredFormFieldNames)&&void 0!==e&&e.includes(t.name))}))):this.formFieldValueCallbacks.setFormFieldValues(a)}_handleError(t,e){Object(n.i)(`Loading or updating ${e} failed:\n\n${t.message}`)}_request(t,e,a){Object(m.a)(null!=this.state.authPayload,"Cannot call request without authPayload");const s=a instanceof FormData||"object"!=typeof a?null:{"Content-Type":"application/json"},o={"X-PSPDFKit-Token":this.state.authPayload.token,"PSPDFKit-Platform":"web","PSPDFKit-Version":"protocol=4, client=2021.4.2, client-git=12fc65bf3a",...s};return fetch(`${this.state.serverURL}${t}`,{method:e,headers:o,body:a instanceof FormData?a:"object"==typeof a?JSON.stringify(a):void 0,credentials:"include"})}_verifyLoaded(){if(!this.state.isLoaded)throw new Error("not loaded")}setIgnoredFormFieldNames(t){this.state=this.state.set("ignoredFormFieldNames",t)}}}}]);